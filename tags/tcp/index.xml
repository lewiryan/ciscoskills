<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>TCP on Cisco Skills</title>
    <link>https://ciscoskills.net/tags/tcp/</link>
    <description>Recent content in TCP on Cisco Skills</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 20 Jun 2018 16:30:14 +0000</lastBuildDate><atom:link href="https://ciscoskills.net/tags/tcp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Too Many TCP Resets</title>
      <link>https://ciscoskills.net/2018/06/too-many-tcp-resets/</link>
      <pubDate>Wed, 20 Jun 2018 16:30:14 +0000</pubDate>
      
      <guid>https://ciscoskills.net/2018/06/too-many-tcp-resets/</guid>
      <description>
        
          &lt;p&gt;So, recently we enforced some firewall rules on a new environment, we did testing of the environment and everything was working as expected. In about 24 hours a lot of traffic from the web infrastructure was being denied and it continued, at first glance it looked like return traffic was being dropped, the web servers were sourcing at port 443 and the destination ports were using dynamic ports (RFC 6335) No user or application problems were reported when we enforced rules, and we waited additional days to see if anything came up. Nothing came up, the only thing was a spike in amount of syslog messages of dropped traffic coming from the web servers.&lt;/p&gt;
&lt;p&gt;So from that point it really wasn’t an issue, but I thought it would be interesting to see what was going on. I started to look at the firewall logs and enabled debugging to syslog, and as you can see the TCP session is being built and we can also see the TCP Teardown, which should be the end of it, something else was happening instead and it was unexpected.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Wed Jun 20 11:58:46 2018;172.17.70.1; &amp;lt;167&amp;gt;Jun 20 2018 11:58:45 172.17.70.1 : %ASA-7-302013: &lt;code&gt;Built inbound TCP connection 47772320 for OUTSIDE:203.0.113.147/43918 (203.0.113.147/43918) to INSIDE:172.17.77.250/443 (172.17.77.250/443)&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Wed Jun 20 12:00:51 2018;172.17.70.1; &amp;lt;167&amp;gt;Jun 20 2018 12:00:50 172.17.70.1 : %ASA-7-302014: &lt;code&gt;Teardown TCP connection 47772320 for OUTSIDE:203.0.113.147/43918 to INSIDE:172.17.77.250/443 duration 0:02:05 bytes 107244 TCP FINs from INSIDE&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Wed Jun 20 12:00:51 2018;172.17.70.1; &amp;lt;167&amp;gt;Jun 20 2018 12:00:50 172.17.70.1 : %ASA-7-106015: &lt;code&gt;Deny TCP (no connection) from 172.17.77.250/443 to 203.0.113.147/43918 flags RST  on interface INSIDE&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The web servers (172.17.77.250) are sending a RST (Reset) Flag back out the firewall which gets denied. This deny action generates the log message that I was seeing, but why would server 172.17.77.250 be sending a rest flag when the connection was already completed?  To investigate this further I needed to do a packet capture to be able to determine what else is going on, maybe we where loosing traffic upstream and this was just a dirty TCP session I really couldn’t tell, so I started to capture the inside and outside interfaces on this firewall and here are the results:
&lt;strong&gt;Inside Interface Capture&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;33437: 12:00:47.907301       &lt;code&gt;172.17.77.250.443 &amp;gt; 203.0.113.147.43918: F&lt;/code&gt; 2320205170:2320205170(0) ack 991843171 win 65535&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;33438: 12:00:47.952480       &lt;code&gt;203.0.113.147.43918 &amp;gt; 172.17.77.250.443: . ack&lt;/code&gt; 2320205171 win 65535&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;33748: 12:00:50.443687       &lt;code&gt;203.0.113.147.43918 &amp;gt; 172.17.77.250.443: F&lt;/code&gt; 991843171:991843171(0) ack 2320205171 win 65535&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;33749: 12:00:50.443687       &lt;code&gt;203.0.113.147.43918 &amp;gt; 172.17.77.250.443: R&lt;/code&gt; 991843172:991843172(0) ack 2320205171 win 0&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;33750: 12:00:50.443748       &lt;code&gt;172.17.77.250.443 &amp;gt; 203.0.113.147.43918: R&lt;/code&gt; 2320205171:2320205171(0) win 0&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;On the first capture we can see the server 172.17.77.250 sending a FIN as noted with the letter “F”, so the server starts to end the connection. Following that we can see the client sending an acknowledgment as noted with the “. Ack”. We can also see that the client sends a FIN to finish up the connection. What’s interesting is at the same time the FIN is sent from the client a TCP Reset is also sent from the client. Normally we should have just ended the connection with a FIN and one more acknowledgment (ACK) from 172.17.77.250 since it started the TCP termination process. This would have end the connection peacefully, however in this example the client seems to send a FIN and a RST at the same time which causes 172.17.77.250 to also send a TCP RST back to the client.&lt;/p&gt;
&lt;p&gt;If we looked at the outside interface capture, we pretty much see the same thing we can see the FIN being sent from 172.17.77.250 and acknowledgment from the client. The client sends the FIN and the reset flags back to 172.17.77.250 which ultimately should have just been a FIN, instead its FIN and RST. Notice we did not see 172.17.77.250 TCP RST across, this was because that packet was already denied from the inside interface.
&lt;strong&gt;Outside Interface Capture&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;32158: 12:00:47.907316       &lt;code&gt;172.17.77.250.443 &amp;gt; 203.0.113.147.43918: F&lt;/code&gt; 3349673389:3349673389(0) ack 965033113 win 65535&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;32159: 12:00:47.952480       &lt;code&gt;203.0.113.147.43918 &amp;gt; 172.17.77.250.443: . ack&lt;/code&gt; 3349673390 win 65535&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;32468: 12:00:50.443672       &lt;code&gt;203.0.113.147.43918 &amp;gt; 172.17.77.250.443: F&lt;/code&gt; 965033113:965033113(0) ack 3349673390 win 65535&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;32469: 12:00:50.443687       &lt;code&gt;203.0.113.147.43918 &amp;gt; 172.17.77.250.443: R&lt;/code&gt; 965033114:965033114(0) ack 3349673390 win 0&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;I was not seeing this on every connection that was being made and the fact that this client was sending TCP RST at the end of the FIN tell us that it’s something the client is doing. I was able to run a test on my own against this to see what a good “peaceful” connection looks like to compare the results. I ran the same functions as what this client would be doing. In this example my IP address is 192.0.2.167, here are the results. From the firewall debugging logs we can see the TCP session being built for 192.0.2.167 and the TCP teardown, also notice we don’t see any denied TCP connections from 172.17.77.250, so that’s a good start!&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Wed Jun 20 14:22:39 2018;172.17.70.1; &amp;lt;167&amp;gt;Jun 20 2018 14:22:34 172.17.70.1 : %ASA-7-609001: &lt;code&gt;Built local-host OUTSIDE:192.0.2.167&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Wed Jun 20 14:22:39 2018;172.17.70.1; &amp;lt;167&amp;gt;Jun 20 2018 14:22:34 172.17.70.1 : %ASA-7-302013: &lt;code&gt;Built inbound TCP connection 49008818 for OUTSIDE:192.0.2.167/3954 (192.0.2.167/3954) to INSIDE:172.17.77.250/443 (172.17.77.250/443)&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Wed Jun 20 14:22:55 2018;172.17.70.1; &amp;lt;167&amp;gt;Jun 20 2018 14:22:51 172.17.70.1 : %ASA-7-302014: &lt;code&gt;Teardown TCP connection 49008818 for OUTSIDE:192.0.2.167/3954 to INSIDE:172.17.77.250/443 duration 0:00:16 bytes 1051013 TCP FINs from OUTSIDE&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Wed Jun 20 14:22:55 2018;172.17.70.1; &amp;lt;167&amp;gt;Jun 20 2018 14:22:51 172.17.70.1 : %ASA-7-609002: &lt;code&gt;Teardown local-host OUTSIDE:192.0.2.167 duration 0:00:16&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Looking at the packet capture we can also see peaceful TCP sessions closing:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;544: 14:22:51.372035       &lt;code&gt;192.0.2.167.3954 &amp;gt; 172.17.77.250.443: F&lt;/code&gt; 221753878:221753878(0) ack 2290377569 win 64296 &amp;lt;nop,nop,timestamp 1618672784 1798676063&amp;gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;545: 14:22:51.372218       &lt;code&gt;172.17.77.250.443 &amp;gt; 192.0.2.167.3954: P 2290377569:2290377600(31)&lt;/code&gt; ack 221753879 win 64296 &amp;lt;nop,nop,timestamp 1798678251 1618672784&amp;gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;546: 14:22:51.372234       &lt;code&gt;172.17.77.250.443 &amp;gt; 192.0.2.167.3954: F&lt;/code&gt; 2290377600:2290377600(0) ack 221753879 win 64296 &amp;lt;nop,nop,timestamp 1798678251 1618672784&amp;gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;547: 14:22:51.397608       &lt;code&gt;192.0.2.167.3954 &amp;gt; 172.17.77.250.443: . ack 2290377600&lt;/code&gt; win 64296 &amp;lt;nop,nop,timestamp 1618672790 1798678251&amp;gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;548: 14:22:51.397699       &lt;code&gt;192.0.2.167.3954 &amp;gt; 172.17.77.250.443: . ack&lt;/code&gt; 2290377601 win 64296 &amp;lt;nop,nop,timestamp 1618672790 1798678251&amp;gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The client (me) requested to finish up the connection, 172.17.77.250 is doing a TCP Push back to us we wait for the FIN from 172.17.77.250 which comes to us shortly. After that you can see two acknowledgments both are from me. The first ACK is for that TCP Push packet that was created by 172.17.77.250, the second ACK from the client (me) is acknowledgment of the FIN. We have ended the connection peacefully and that’s how it should be.&lt;/p&gt;
&lt;p&gt;However, the Internet is a weird place and that’s not what’s happening, so what’s the issue? Well that really was hardest part of this problem and here’s my theory, 172.17.77.250 is sending a TCP RST back to the client is because 172.17.77.250 wasn’t expecting it in the first place. It was finishing up the connection between the client and because of this unexpected TCP packet from the client 172.17.77.250 sends a TCP RST. The connection is not valid, and our server wants to start over. In the meantime, the TCP session was already closed by the firewall because it saw that last FIN from the client. That last TCP RST packet from the server gets denied and never reaches the client, but that still does not answer our question.&lt;/p&gt;
&lt;p&gt;Why are seeing a FIN and RST from the client in the first place? This TCP connection is using TLS, so I started to look at how TLS functions in a TCP connection. When communication starts, and we finish our TCP handshake, then if the connection is over TLS we do a TLS handshake-&amp;gt; After the two hosts agree on the ciphers and TLS settings data is exchanged encrypted-&amp;gt;After TLS is done with the data TLS &lt;strong&gt;should&lt;/strong&gt; send a close notify to “peacefully” end the TLS session-&amp;gt;Following that TCP closes with a FIN and it is peaceful. :)&lt;/p&gt;
&lt;p&gt;I couldn’t investigate the TLS packet because it was encrypted however I think it had something to do with the close notify action of TLS. Not all implementations of SSL/TLS follow that rule even through RFC 5246 seems to imply that a close notify is required. I think this would explain the reason why the server sends RST when it receives both a FIN and RST at the same time from the client, it was unexpected, and we did not close the TLS session properly. When I did the test, I didn’t get any TCP resets. Although we where not seeing any disruptions from this it was helpful to at least figure out what the problem is and then being able to theorize what we could do to fix that problem.&lt;/p&gt;
&lt;p&gt;In this example its related to the client so we can’t do anything on our end. The fact that this is happening at the end of the TCP connection, you are not going to notice anyway because you already have data you requested. We don&#39;t really care how the connection closes. I hope this post was helpful in understanding how to dig in the weeds and even through the connection worked, its helpful to understand any anomalies because those could turn into problems in the future.&lt;/p&gt;

        
      </description>
    </item>
    
    <item>
      <title>Understanding TCP</title>
      <link>https://ciscoskills.net/2011/02/understanding-tcp/</link>
      <pubDate>Fri, 25 Feb 2011 18:10:59 +0000</pubDate>
      
      <guid>https://ciscoskills.net/2011/02/understanding-tcp/</guid>
      <description>
        
          &lt;h2 id=&#34;this-tutorial-is-going-to-betalking-about-the-tcp-protocolhttpenwikipediaorgwikitransmission_control_protocol-transmission-control-protocol-every-time-you-connect-to-a-website-you-are-using-the-http-protocolhttpenwikipediaorgwikihypertext_transfer_protocol-hypertext-transfer-protocol-but-below-that-you-are-also-using-a-tcp-protocol-the-nature-of-tcp-is-to-provideerror-recovery-there-are-other-services-or-applications-that-use-tcp-http-however-is-a-common-protocol-that-is-used-in-online-applications-remember-tcp-is-not-the-only-protocol-in-the-transport-layerhttpenwikipediaorgwikitransport_layer-transport-layer-of-the-osi-modelhttpenwikipediaorgwikiosi_model-osi-model-there-is-another-called-udphttpenwikipediaorgwikiuser_datagram_protocol-user-datagram-protocol-but-thats-another-day--tcp-stands-for-transmission-control-protocol-what-makes-tcp-shine-is-its-error-recoveryhttpenwikipediaorgwikierror_detection_and_correction-error-detection-and-correction-this-helps-other-protocolshttpenwikipediaorgwikicommunications_protocol-communications-protocolbelow-not-worry-about-if-the-packet-was-droppedbecause-tcp-will-requestthat-packet-again-with-all-of-that-overhead-in-tcp-it-does-require-more-bandwidth-and-processing-compared-to-the-udp-protocol-tcp-has-several-fields-in-the-header-as-pictured-belowthe-tcp-header-fieldhttpsystemstechblogfileswordpresscom201102tcpheaderjpgw300-tcp-headerhttpsystemstechblogwordpresscom20110225understanding-tcptcpheader-like-mentioned-tcp-has-reliability-error-recovery-this-is-madepossible-by-using-sequence-and-acknowledgment-numbers-byteshttpenwikipediaorgwikibyte-byte-in-the-tcp-header-field-take-the-example-below-the-acknowledgment-field-in-the-tcp-header-that-was-sent-by-theweb-browser-was-4000-this-implies-the-next-byteto-bereceived-will-have-a-sequence-number-of-4000tcp-seq-and-ackhttpsystemstechblogfileswordpresscom201102tcp-sqackpngw300-tcp-sqackhttpsystemstechblogwordpresscom20110225understanding-tcptcp-sqack-since-the-sequence-and-acknowledgment-numbers-count-the-number-of-bytes-this-helps-with-error-control-if-a-tcp-segment-was-lost-or-caused-an-error-the-web-browserhttpenwikipediaorgwikiweb_browser-web-browserwould-send-an-acknowledgment-that-the-web-server-that-would-not-be-expecting-and-resend-any-lost-data-an-example-would-be-if-the-web-browser-only-received-2000-bytes-the-client-would-send-an-acknowledgment-of3000-bytes-when-the-web-server-received-that-information-it-knows-that-it-sent-3000-bytes-of-data-and-the-acknowledgment-field-should-be4000-the-web-server-would-resend-the-third-segment-again-and-wait-of-an-acknowledgment-of-4000tcp-drophttpsystemstechblogfileswordpresscom201102tcp-droppngw300-tcp-drophttpsystemstechblogwordpresscom20110225understanding-tcptcp-drop-another-feature-tcp-has-is-calledflow-control-this-uses-the-window-field-which-determines-the-maximumamount-unacknowledged-bytes-at-a-given-time-the-size-starts-out-small-and-if-no-errors-occur-then-the-window-size-increases-the-number-of-unacknowledged-bytes-this-speeds-up-time-needed-to-download-the-information-if-errors-start-to-occur-then-the-windows-size-decreases-keep-in-mind-that-this-field-will-change-often-as-it-will-continue-try-to-raise-the-number-of-unacknowledged-bytestcp-windowhttpsystemstechblogfileswordpresscom201102tcp-windowpngw300-tcp-windowhttpsystemstechblogwordpresscom20110225understanding-tcptcp-window-tcp-is-also-does-a-connectionestablishment-and-termination-this-happens-before-any-data-is-sentis-it-will-also-start-the-sequence-numbers-acknowledgment-numbers-and-agree-on-the-port-numbershttpenwikipediaorgwikiport_number-port-numberto-use-this-three-way-handshake-happens-in-beginning-and-at-the-end-when-the-data-transfer-is-complete-the-flags-it-uses-in-the-tcp-header-are-syn-which-means-synchronize-the-sequence-numbers-ack-which-is-an-acknowledgment-field-and-to-terminate-or-finish-the-connection-it-will-send-a-fin-bit-although-this-a-brief-tutorial-and-how-tcp-works-in-gives-you-an-understanding-of-the-main-components-that-are-involvedin-setting-up-a-tcp-connection-and-finishing-a-connection-like-always-i-encourage-you-if-you-would-like-more-information-a-web-search-will-do-along-with-visiting-ciscocom-i-hope-this-tutorial-was-helpful&#34;&gt;This tutorial is going to be talking about the &lt;a href=&#34;http://en.wikipedia.org/wiki/Transmission_Control_Protocol&#34; title=&#34;Transmission Control Protocol&#34;&gt;TCP protocol&lt;/a&gt;. Every time you connect to a website you are using the &lt;a href=&#34;http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol&#34; title=&#34;Hypertext Transfer Protocol&#34;&gt;HTTP protocol&lt;/a&gt;, but below that you are also using a TCP protocol. The nature of TCP is to provide error recovery; there are other services or applications that use TCP. HTTP however is a common protocol that is used in online applications.  Remember TCP is not the only protocol in the &lt;a href=&#34;http://en.wikipedia.org/wiki/Transport_Layer&#34; title=&#34;Transport Layer&#34;&gt;transport layer&lt;/a&gt; of the &lt;a href=&#34;http://en.wikipedia.org/wiki/OSI_model&#34; title=&#34;OSI model&#34;&gt;OSI model&lt;/a&gt;, there is another called &lt;a href=&#34;http://en.wikipedia.org/wiki/User_Datagram_Protocol&#34; title=&#34;User Datagram Protocol&#34;&gt;UDP&lt;/a&gt; but that&#39;s another day. :) TCP stands for (Transmission Control Protocol) what makes TCP shine is its &lt;a href=&#34;http://en.wikipedia.org/wiki/Error_detection_and_correction&#34; title=&#34;Error detection and correction&#34;&gt;error recovery&lt;/a&gt;, this helps other &lt;a href=&#34;http://en.wikipedia.org/wiki/Communications_protocol&#34; title=&#34;Communications protocol&#34;&gt;protocols&lt;/a&gt; below not worry about if the packet was dropped because TCP will request that packet again. With all of that overhead in TCP it does require more bandwidth, and processing compared to the UDP protocol. TCP has several fields in the header as pictured below.  &lt;a href=&#34;http://systemstechblog.wordpress.com/2011/02/25/understanding-tcp/tcpheader/&#34;&gt;&lt;img src=&#34;http://systemstechblog.files.wordpress.com/2011/02/tcpheader.jpg?w=300&#34; alt=&#34;The TCP Header Field&#34; title=&#34;tcp-header&#34;&gt;&lt;/a&gt; Like mentioned TCP has reliability (error recovery) this is made possible by using sequence and acknowledgment numbers (&lt;a href=&#34;http://en.wikipedia.org/wiki/Byte&#34; title=&#34;Byte&#34;&gt;bytes&lt;/a&gt;) in the TCP header field. Take the example below the acknowledgment field in the TCP header that was sent by the web browser was 4000, this implies the next byte to be received will have a sequence number of 4000.  &lt;a href=&#34;http://systemstechblog.wordpress.com/2011/02/25/understanding-tcp/tcp-sqack/&#34;&gt;&lt;img src=&#34;http://systemstechblog.files.wordpress.com/2011/02/tcp-sqack.png?w=300&#34; alt=&#34;TCP SEQ and ACK&#34; title=&#34;TCP-SQACK&#34;&gt;&lt;/a&gt; Since the sequence and acknowledgment numbers count the number of bytes, this helps with error control if a TCP segment was lost or caused an error the &lt;a href=&#34;http://en.wikipedia.org/wiki/Web_browser&#34; title=&#34;Web browser&#34;&gt;web browser&lt;/a&gt; would send an acknowledgment that the web server that would not be expecting and resend any lost data. An example would be if the web browser only received 2000 bytes, the client would send an acknowledgment of 3000 bytes. When the web server received that information it knows that it sent 3000 bytes of data and the acknowledgment field should be 4000. The web server would resend the third segment again and wait of an acknowledgment of 4000.  &lt;a href=&#34;http://systemstechblog.wordpress.com/2011/02/25/understanding-tcp/tcp-drop/&#34;&gt;&lt;img src=&#34;http://systemstechblog.files.wordpress.com/2011/02/tcp-drop.png?w=300&#34; alt=&#34;TCP Drop&#34; title=&#34;tcp-drop&#34;&gt;&lt;/a&gt; Another feature TCP has is called flow control; this uses the window field which determines the maximum amount unacknowledged bytes at a given time. The size starts out small and if no errors occur then the window size increases the number of unacknowledged bytes. This speeds up time needed to download the information. If errors start to occur then the windows size decreases, keep in mind that this field will change often as it will continue try to raise the number of unacknowledged bytes.  &lt;a href=&#34;http://systemstechblog.wordpress.com/2011/02/25/understanding-tcp/tcp-window/&#34;&gt;&lt;img src=&#34;http://systemstechblog.files.wordpress.com/2011/02/tcp-window.png?w=300&#34; alt=&#34;TCP Window&#34; title=&#34;TCP-Window&#34;&gt;&lt;/a&gt; TCP is also does a connection establishment and termination. This happens before any data is sent is it will also start the sequence numbers, acknowledgment numbers and agree on the &lt;a href=&#34;http://en.wikipedia.org/wiki/Port_number&#34; title=&#34;Port number&#34;&gt;port numbers&lt;/a&gt; to use. This three-way handshake happens in beginning and at the end when the data transfer is complete. The flags it uses in the TCP header are &amp;quot;SYN&amp;quot; which means synchronize the sequence numbers. &amp;quot;ACK&amp;quot; which is an acknowledgment field and to terminate or finish the connection it will send a &amp;quot;FIN&amp;quot; bit. Although this a brief tutorial and how TCP works in gives you an understanding of the main components that are involved in setting up a TCP connection and finishing a connection. Like always I encourage you if you would like more information a web search will do, along with visiting Cisco.com. I hope this tutorial was helpful.&lt;/h2&gt;
&lt;h3 id=&#34;comments&#34;&gt;Comments:&lt;/h3&gt;
&lt;h4 id=&#34;heading&#34;&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;http://ciscoskills.net/2011/03/04/wordpress-com-hit-by-a-dos-attack/&#34; title=&#34;&#34;&gt;WordPress.com Hit by a DoS Attack | Cisco Skills&lt;/a&gt; - &lt;time datetime=&#34;2011-03-04 08:41:33&#34;&gt;Mar 5, 2011&lt;/time&gt;&lt;/p&gt;
&lt;p&gt;[...] out my recent post of Understanding TCP to learn how the TCP protocol works in a simplified form. You can also find more information about [...]&lt;/p&gt;
&lt;hr /&gt;

        
      </description>
    </item>
    
  </channel>
</rss>
